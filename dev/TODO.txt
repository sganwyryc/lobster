- reference counting is a good default, but it is a source of much more inefficiency than I had
  guessed. Should consider what it would take to add a friendly ownership model.
  Examples:
  - My past languages SHEEP and CryScript
    - SHEEP has full value semantics, which to the user looks like copies, with lots of built-in
      operators and functions that make use of linearity to do in-place updates.
      it has: newvec, oldelem = oldvec[i <- newelem] as a way to update a data structure, which
      ensures nothing is copied or thrown away. If newelem is nil, it becomes a cheap way to
      take an expensive element out of a vector without copying.
      It has limited borrowing, with built-in functions annotated as "promise I won't keep a
      reference"
    - CryScript produced a tree of regions at runtime, where regions are attached to certain
      object types. regions would be entered and excited automatically with methods on that type.
      You can explicitly designate a parent region to e.g. allocate things to be returned from
      a boundary method. Trying to create a reference from outside a region to inside was
      disallowed at runtime.
  - ParaSail
    the semantics of all data structures are by value, sees an object with a nillable field
    as "extending" a flat value when set. does copy/move/swap, but does not have borrow.
    Has an interesting loop syntax that "hides" borrowing to get around the lack of borrowing.
    https://en.wikipedia.org/wiki/ParaSail_(programming_language)
    https://drive.google.com/file/d/0B6Vq5QaY4U7ubm5qVkFpMEtmN2s/view
  - Rust. needs waaay to many type annotations and relatively complex analysis to work.
    definitely needs to be simpler than this.
    - Example of the horror to avoid:
      https://rust-leipzig.github.io/architecture/2016/12/20/idiomatic-trees-in-rust/
      (his library does NOT even implement a delete method!)
    - https://stackoverflow.com/questions/34747464/implement-graph-like-datastructure-in-rust
      Basically, you either use an arena (and leak!) or you use a hashmap (and have potentially
      dangling references).
    - So rust is really only nice if you can keep to really simple data structures?
  - Nim: seems to have a nice middle ground inspired by ParaSail.
    https://nim-lang.org/araq/destructors.html
    https://github.com/nim-lang/Nim/wiki/Destructors
  We'd want to keep Lobsters light syntax, so any system that requires type annotations
  frequently can't be used. 99% of code should "just work", even if it occasionally makes
  copies you don't expect.
  Unlike Rust, we don't have to care about a single mutable borrow, since we don't have any
  interior pointers nor do we intend to do shared memory concurrency.
  In terms of ownership, we have two modes: move (transfer ownership) vs borrow (can be mutable
  or not).
  - an expression/constructor always moves.
  - an assigment wants to move.
  - a variable can be initialized either by a move (most expressions) or a borrow (an expression
    that reads from a data structure or variable).
    - if it was a borrow, all its uses must be borrows as well. The parent variable must be
      be marked as having been borrowed from, which disallows deletion etc., and must outlive
      the borrow.
    - if it was a move, it owns the data. all uses must be borrows, except the last one may
      be a move.
      - a special case can be made to allow moves into data structures that are not the last
        use, e.g. a := newobject; x.y = a; use(a), since the code after the can be transformed into
        a` := x.y; use(a`)
        Can do the same with push(), i.e. code afterwards becomes a borrow on the last element
        of a vector, which locks the vector as "borrowed from"
  - function arguments should default to borrow (mutable or not), but can be marked as move
    in special cases. Move is used for:
    - putting inside a data structure, such as push()
    - arguments that are lobster "value" types when the result is also a value, this way
      the memory can be used in-place.
  - function return values usually move. they can borrow if the exp is field/var reference,
    if we can correlate the parent to var in the caller?
  So now, for any value being passed, if source and dest modes are NOT equal, we get:
  - if src wants to move, and dest wants to borrow, then src has to delete after borrow ends.
  - if src wants to borrow, and dest wants to move:
    - if it is non-mutable, a copy is made.
    - if it is mutable, error. This is because a copy would change semantics.
      (see variables above for how this can be overcome in some situations)
  In both cases the "fix" is done by the src (caller), which increases the chances the fix
  can be avoided (as opposed to the callee always allocating/deallocating).
  In theory we could use lobster specialization to let the caller determine if they want
  move/borrow for each param, and specialize if they differ per call. That way each code
  pattern is efficient. Sadly that also means that a mutable borrow after move will error
  at the move, rather than at the borrow.
  So maybe better to resolve these after the function has type checked.
  Implementation wise, we have the advantage that for a while we can keep refc, so we can
  check the inserted deletions against the refc to see if they're correct.
  The good news is that this system can be entirely done without annotations of any kind,
  and is efficient (only values are copied, which currently are always small).
  The big downsides are that you can't form DAGs or graphs anymore.
  Would adding non-mutable vectors have any advantages? those could always be consumed by a move.
  Another way to look at it is this simple starting point: for each function block, end by
  deallocating eveything locals hold, but never deallocate arguments. Then most of the lifetime
  analysis is about when to change those defaults for particular variables.

  Its pretty easy to still have refcounting as well, simply by having a level of indirection
  (a cell object referring to a refc object) this way the cost of refc is only paid by these
  objects, and inc/dec can happen at creation/destruction of the cell object (so is cheaper
  than the refcounting we have now, since you don't pay the cost on any parameter passing).
  Interestingly, you could actually use this for all values: an ownership analysis, which all
  it does is compute lifetimes for all refs, and inserts an incref where the above algo would
  do a copy/error.
  Or more generally, you could allow the programmer to specify what he wants to happen on a
  multi-ref: a copy (for non mutable / small / stack alloc), an error (for efficient mutables),
  or an incref (for flexible mutables).
  We can achieve this with a 3rd type beyond value / struct.. maybe "owned" or "linear"?
  Or make struct linear, and have a "reference" or "shared" type.
  The other cool thing in terms of seeing things this way is that you can first implement
  the reference count for all types, see that it works, and then only after introduce the other
  two.

- a buffer type.
  Similar to Go slices and https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html
  similar to a string but resizable.
  similar to a vector, but bytes, and with multiple views on one buffer.
  user-facing type is the view, which simply has buffer pointer, start & size.
  buffer is hidden and has refc, capacity (at negative offsets), and data.
  (this is a different refc from the one used by all language values.. this buffer will always
  be refc even if views become linear/value)
  When you write data, it is always an append on the view, i.e. at offset size, and size then
  grows for that view.
  When you read data, you consume data from start, and start increases. You cannot read past
  size.
  If you'd write past capacity, the buffer gets reallocated.
  The new buffer is only visible to the current view. It is up to the programmer to share this
  buffer when growing. This could of course be avoided with yet another indirection, but it
  would be a problem very infrequently.
  It would be cleanest if all write functions returned a new view, but thats maybe a bit wasteful.
  These views can be the basis of FlatBuffer handles for example, and can even have special
  purpose FlatBuffer ops.
  Hmm.. rather than a buffer type, why not reuse the existing string type for this? would be
  even more versatile, and all the new functionality can also make more complex string builders
  possible.
  One downside of buffers also being strings is that having all these kinds
  of buffers in your program that are all "string" gets potentially confusing,
  so would be good to add strong typedefs:

- strong typedefs.
  Will basically add a tag to any base type.
  If a functionally specifically requests the tag, the tags must match.
  In any context a type is allowed to lose its tags (coerced to base).
  This way, we can have the few functions that actually want string to contain
  utf-8 take this typedef. Or strings can specify they contain a FlatBuffer
  or some other specific binary layout.
  For scalars and vectors, the tricky thing is that you want some weird
  defaults for operators:
  for +, strong + strong = strong, anything else results in base type.
  for *, strong * base = strong, since you're often scaling a unit.
  It should be possible to override these defaults, disable operators, or
  specify relations with other types, but the default for a type should work
  intuitively for most types (especially spatial quantities, as Lobster is
  game oriented). This overriding is something for later.
  Besides the type system dealing correctly with tags, we now need general
  casts (allow a typedef as function name). We may also need to make string
  constants result in a utf-8 typedef by default.

- Features to make it easier to use structs ADT style as opposed to inheritance
  - ADT is similar to a base class with no members and a fixed set of sub-classes.
    - So make that use case into a simpler declaration syntax.
  - extend switch to do pattern matching.
  - do we still want multi-methods? certainly allowing both ADT and inheritance
    styles is more flexible, but multimethods aren't particularly fast right
    now and probably don't support inheritance that well. Either just:
    - support inheritance well and efficiently.
    - reduce their use case to be an alternative to pattern matching on an ADT.
    - remove them altogether.

- things that would help making --to-cpp faster:
  - a central problem is that improving a lot of these means duplicating large segments of
    the instruction space for refc and not, or the 5 instructions that use an lvalop.
    The reason we have to keep doing this is factoring it into lots of smaller instructions
    is too slow for an interpreter.
    So we could probably make a lot more progress if we could first default to an execution
    method that does not have as much instruction overhead.
    Options:
    - A simple jit would not be hard since most are calls, but would miss inlining. Now
      we'll have extra work to do to special purpose compile things to the JIT that so far
      have been simple instructions.
      - Maybe LLVM as jit can do inlining assuming I have the rest of the code also available
        as .ll, but that becomes almost as unwieldy as going thru C++.
    - Always invoking C++ means easy inlining and easy instruction definition, but complicates
      things / slows things down in always needing to invoke a C++ toolchain.
      - Also easy to profile and debug compared to JIT.
    - Just keep moving forward with an unwieldy instruction set, since it is the simplest.
  - fmul/fadd are expensive??
  - inline LvalueOp.
  - specialized indexing op that gets vector variable instead of vector on stack, this way
    you can avoid an inc and a dec.
    - find other opportunities to reduce inc and dec.
    - or, generically, make specialized pushvar that does not inc, and ops that consume it
      that do not dec, and analyze when such pairs can be used.
  - find places where the trampoline can be avoided, especially for for() and its body.
    - should be easy when return X is followed by X:
    - with the switch based version could do direct jumps, but switch trashes the branch cache?
    - experiment with real gotos?
  - reduce use of ElemType.

- Make includes explicitly depend on eachother.

- switch jump table based version.

- Ways to represent "value" structs as in-line values.
  Easiest may be to make a 3 field struct actually take up 3 fields in the parent, that way
  quite a bit of code can ignore the distinction.
  "pos.x" instructions can be emitted as just "x"
  Still, the amount of places in the code that assume they can pass along a single Value for
  a struct is gigantic, and these all would need to be made in-inline specialized.
  Unless, we allow a Value that is a pointer to a struct, as a short-lived thing to allow
  it to be passed to built-in functions etc. But that is also tricky, because now we need
  to guarantee it is short-lived enough to create a dangling pointer. Certainly with co-routines
  etc this may be hard.
  If its only used with built-in functions this may be ok, since they never call into additional
  code.
  Additional issue is how to know the type, or at least the number of elements. The parent should
  be able to provide this, but it needs to be plumbed thru.
  Vectors of such structs now need to be size aware.
  Would it be nice to generally make everything size-aware if we do this, so we can also have
  8/16/32/64 bit values etc. Though that is certainly a lot harder.
  A way to make a gradual path to this is:
  - First put structs inside other structs by making the inner one still have its own refc,
    and increasing the parent refc. Then when the destructor is called, it can decrease the
    parent refc. This way, pointers to inner structs can be passed along safely lifetime wise.
  - For stack frames something similar, but now the stack unwind can generate a runtime error if
    the inline struct refc is not 0.
    - Probably better to first transition to unwinding being done by code, which would simplify
      this.
  - Must of course have new assignment ops for these structs since it needs to overwrite.

- 32-bit pointers in 64-bit
  - exampler: https://wiki.openjdk.java.net/display/HotSpot/CompressedOops
  - If all objects are 8-byte aligned, and if a << 3 is ok, can address 32GB.
  - if the base address is a multiple of 4GB, then compressing can be a simple truncate
    instead of add/substract, and no conditional to compress a nullptr.
  - needs a conditional to decompress nullptr, unless base address can be 0. That's a huge win,
    which may be possible be we can assume a 32GB range.
    - though we have seperate accessors for pointers that can be null, so if the majority is not of
      that type, it may be ok.
    - still, not having a base address may be a win by itself.
    - can simply iterate with mmap to find a large block as low in memory as possible.
      that should generally not fail?
      - On Windows, simply turning of ASLR (/HIGHENTROPYVA:NO) allows compressed pointers to
        work without additional work.
  - will NOT work in the default trampoline compiled mode, since we store function pointers in
    values there. Have to use the switch mode instead.
  - More good tips in the comments here:
    https://stackoverflow.com/questions/50429365/what-is-the-most-reliable-portable-way-to-allocate-memory-at-low-addresses-on

- would nil as sentinel have advantages?
  - would need to specialize lots of opcodes and functions that call .True(), so probably not.

- besides exception.lobster, another nice error-handling strategy would be to use nillable to
  signal errors. returning nil is a bit primitive, but in lobster it has the nice property that
  it forces the caller to check for nil, making errors not-ignorable. It also means we can
  use standard language tools like if/and/assert rather than special purpose error handling.
  - would need some way to store additional error information external to the value.
    in the simplest case a global last_error:string
  - doesn't work on functions that want to return scalars. should really make boxed values
    possible outside of any, such that you can actually have int? types.
  - the best language addition for this which is generally useful would be to have
    a := return if not f()
    where f returns a nillable, a is non-nillable, an the surrounding function again returns a
    nillable.
    as an easy way to perculate errors.
    in e.g. Rust this is a macro that looks like: let a = try!(f())
    Probably a more verbose syntax that contains "return" is better, since returning from a
    function is major control-flow that you don't want hidden in a macro. Also nice that in an
    editor you can highlight all the returns.
    Can also have "return if" that does the reverse: return a non-nillable if true, otherwise
    continue execution. This is like doing "return f() or .." except here it is easier to
    make the ".." contain multiple statements.
    This is nice, because "return if not" is for NOT dealing with errors locally, whereas
    "return if" is for dealing with errors locally (coming up with an alternative return value
    upon failure).
    "return if" also usefully turns a value non-nil without needing a temp var, normally you'd need:
    temp := f(); if temp: return temp
    Also, both of them promote more linear code.
    - note there is some code in the impl that assumes "return" has no temps on the stack,
      which isn't the case for: 1 + 2 + 3 + (return if not ..)
    - for completeness, can even have "a := return b if not c", which is still better than
      "a := c; if not a: return b"
  - so far there isn't a lot of error handling going on anywhere in lobster code.. I guess
    because games don't do a lot of error handling beyond loading files. And GL errors are
    wrapped in native code.
    Could be good to write something that does a lot of error handling like a parser, then
    again the above constructs sound generally useful

- try again having --tocpp output basic blocks as switch case rather than function pointers.
  - try with clang to see if it optimizes that case better
  - try and explicitly jump to the next function where known statically rather than using the trampoline?

- always fun to rewrite the implementation in itself..
  - this would actually not be super hard.. the frontend and the VM can easily be in different
    languages.
  - can even implement any part of the compiler in lobster itself, by just calling it from C++.
    For example, the parser. it would just need a built-in to construct nodes etc.
    Either interpreted or to-cpp would work.
  - Maybe more productively, as noted elsewhere, could write the graphical debugger UI in
    Lobster itself.

- make extensions (and --tocpp code) into DLLs rather than statically linked?
  - check performance consequences for --tocpp

- 64bit mode improvements:
  - pushflt64?
  - Optimizer can't use 32bit values.

- refactor function return-value tracking as it is highly confusing.
  - Function::nretvals shouldn't exists as it depends on the specialization.
  - SubFunction::returntypes should be allowed to have length 0.
  - Codegen shouldn't have weird exceptions for more than 1 return value.
  - Generally needs to be more exact so Typecheck/Codegen/VM can't get out of sync.
  - Functions that have no meaningful return value but happen to be called as last exp can have
    the requirement of a return value perculate far thru, and occasionally cause 2 specializations
    for no reason.
    - But we also don't want to disallow simple function defs that just return an exp.
    - Maybe if its multi-line it requires an explicit return?

- Since in Lobster values only signed ints get used, and STL uses size_t, there's a fair bit
  of unfortunate casting going on that be nice to remove. Many (including the C++ standards
  committee) seem to agree unsigned size_t was a mistake, so would be nice to move the whole
  codebase towards default-signed for everything, with less casts, and less possible gotchas.
  Could do this by having a global size() for STL containers that returns signed.
  Could repurpose the already existing "intp" type, but that might not always be pointer sized,
  so maybe better a new type (like gsl::index).

- This doesn't typecheck correctly:
  if !lhs:
      lhs = ...
  // lhs here required to be non-nil.

- This doesn't parse:
  somestruct { def ():
    multi-line-anonymous-function-body
  }

- This gives: all return statements of this function must return the same number of return values. previously: 1
    do():
        for 100:
            if true:
                return from do // fixme

- font rendering:
  - it is possible when only very few chars are cached, that they are placed higher in the bitmap
    if all their bounding boxes are small.
  - outline rendering needs to do a better job that pixels stay in the bounding box.

- Can't call o.f() where f is anonymous function value, need to first assign to temp var.

- "assign false" should count as unreachable and not require a well-typed return value after it.

- if we make assert a language feature rather than a builtin, we can make it understand
  equality operators directly, and create specialized asserts that have better errors, i.e.
  any "assert A == B" can actually output the values of A and B.
  or "assert var" is pretty common, which can output the name of the var, etc.

- need some way to typecheck append([type_A], [type_B])
  neither either:
  - some kind of cast (may be universally useful), or compile-time C# "as" (never nil)
  - a way to annotate append as returning the super-type of both inputs.
  - some generic type system smarts that when arg N is supposed to match arg 1,
    if it fails, it first tries to both make them into superclasses before erroring.
  How many functions are there likely to be like this, beyond append?

- typeof gives static type, needs to be dynamic when used with ref objects.

- type errors should skip large amounts of globals for __top_level_expression()

- can't analyze return value for:
  def foo():
      if ..:
         return ""
      nil

- In this kind of code, without the type annotation, the list specializes it to subclass
  and fails the removeobj:
  def supermethod(.., list:[supertype])
      list.removeobj(this)  // Type error without the annotation.
  Not sure how to solve that, as auto-specializing "this" based on other args may be weird.

- in a struct foo { a:float = 1.0 } allow the :float to be left out
  problem is, we already have default values on fields that are intended to be generic, in
  e.g. astar.lobster

- bring indent based syntax for struct defs also to struct use, vectors, enums..

- compile-time lobster execution would be super simple: simply allow a string that contains
  lobster code, spin up a VM to eval it, and insert its result back in the code.
  print eval "1 + 2" would actuall compile: print 3

- if your forget ":" after "else", it is going to try and declare a following identifier as a
  function parameter, see FIXME in ParseTrailingFunctionValues

- extend switch with pattern match facility?

- Should consider to allow on-the fly data structures as well.
  Writing new_type { field1: val, field2: val } would add such specialization to new_type even
  if it doesn't exist yet.
  Should change data structure specializations such that the collection of things under new_type
  doesn't need to share a generic parent, and in fact may have different fields etc.
  Specialization then takes care of checking the different variants in use.

- Should we consider default-const?
  Bit odd for a language without type annotations, but if the syntax for mutation was light,
  it be a very nice feature to have, especially since the vast majority of args don't need it.
  Only needed on struct/vector/coroutine.
  Syntax could be a single char token attached to any ident decl?
  def f(a, @b): b[0] = a
  @a := g()
  where token could be: @ # ~ ! $ & * = ` in that order
  A keyword like "mut" is a bit too obnoxious?
  token could also follow the ident.
  Could allow a command-line arg or annotation in file to indicate that code doesn't care to be
  const-correct :)

- for easier integration of the language part into other projects:
  - rename stdafx.h
    - make public headers explicitly depend on it.
    - try to reduce the scope of it.

- Have a simpler/better C++ binding interface.
  - for starters, should allow current binding system to be loaded from a DLL/so such that
    extensions don't have to be compiled into the main binary.
    - needs some versioning.
    - also, if those extensions need the basic engine functionality, need to first refactor the
      engine functionality to sit in an interface pointer or something.
  - Worth discovering if the current macro glue can be improved, maybe with automatically
    deduced arguments from a C function or C++ method.
  - Could do something similar to CryScript: declare external functions in lobster, generate
    glue code automatically.
    - causes a code-gen step whenever adding new functions.
    - You declare in one place, and the second use is a copy, but the two have to be kept in sync.
      - enforcing the two are in sync is done by the C++ compiler, which is nice.
  - One fun idea is to support Python DLLs/so's.
    There's a TON of C/C++ libraries out there for Python.
    - Such a DLL returns a DLL module structure, which we could traverse to find out what
      functions are in there.
      - They are of course untyped, showing up in Lobster as any functions?
      https://docs.python.org/2/extending/extending.html
      (see also e.g. dynload_win.c in CPython)
    - Not obvious how this would work in terms of memory management, as Lobster would have to
      allocate potentially complicated Python values from Lobster values that then get accessed
      by the DLL (which contains a subset of the Python runtime?)
    - Most interesting libraries like Numpy come with a ton of wrapper code in Python, which means
      just exposing the DLL functions would end up with a very different API, or you'd have to port
      all that Python code.
    Frankly while it would be cool, there's too much of a mismatch for this to make sense?

- function-level profiling of actual time spent.
  The current line level profiler is useful, but counting VM ops is imprecise, and doing it once
  per instruction is wasteful.
  If its inside the function-calling mechanism behind an if (profiling) that is branch predicted,
  it can be always in there (maybe #ifdeffed out for --tocpp).
  Can also count all builtins automatically.
  To do exclusive counts, can simply have a global that counts how much time children have
  accumulated so far, to substract from a parent. This works recursively because it is postfix!

- Should consider type-safe type aliases, where converting from the base type is explicit, mixing
  with the base type degrades the type, and mixing aliases is a type error. Would be a feature
  entirely implemented in the type checker only, as an additional tag on type values.

- would be nice to have on the fly pairs/tuples.

- doesn't type check if c: 0.0 else: 0 correctly, result is any?

- replace typeof return with something better directly part of the syntax.

- make resume into seperate op.

- should somehow avoid functions whose return types aren't used to have matching return types.
  - FIXME: still can't give error when builtin with no retvals requires retval.
  - FIXME: are dynamic function values type checked at all?
  - remove return value checking from parser
  - simplify or remove return value checking from codegen
  - simplify e.g. occurrences of return - from etc that shouldn't need fake return values anymore.
  - also apply this to builtin functions?
  - reqret arg of TypeCheck: if we are sure codegen or optimizer optimizes op out, can
    turn "true" in to passing "reqret" to child.

- add options to either show more extensive stacktrace dump to either stdout or file.

- break statement

- support default args?

- inlining has kind of broken the variable stack trace. not only are certain functions gone,
  it can now show multiple variables of the same name and variables that are not really in scope
  anymore.

- function call optimization and simplication.
  - make a micro-benchmark to compare against other languages.
  - inlining
    - named functions
    - how does removing single-use functions relate to function values stored in variables
      (and in variables of function types), and as arguments to builtins like hash/gl_translate.
  - remove static function arguments
    - or maybe better to generically remove vars that aren't used.
  - remove dynscope
  - C++ backend: detect when not needing to return to trampoline?
    - need to know when "broken" by a function call.
    - though given that the switch/jump method is slower, maybe not a priority.
  - change var access to be relative to top of stack
  - cleanup of id/sid/arg..
  - support functions that don't return anything.
  - make resume a VM op.

- experiment more with frame state now that its faster & cleaner.
  - currently doesn't work well in loops
    - if you loop through entities, and do a time_if, then some may have an ongoing animation
      and some do not, and state of one can easily be used for another.
    - we really need to be able to pass on object identity
  - new implementation should allow:
    - removing arbitrary element in loop - though object identity would be better.
    - access state from 2 contexts
    - explicit reset? to avoid 1 frame of nothing if a reset is forced.
  - dump frame state.
  - create some generic primitives.. frame-based if-then, sequencing, etc.
  - save frame state?
  - DOCS!

- Builtin calls that return no value are followed by IL_POPREF, would be better IL_POP or nothing
  at all.

- Make loadtexturecached into something using a generic map. But to declare it, need to be
  able to specify generic vectors in struct decls.

- consider baking Z up into functions.
  - clean up 3dhelpers?

- have a reference counted resource handle instead of ints.

- Could provide a compilation mode where this is compiled in: https://github.com/bombomby/brofiler
  Would be able to show a nice nested view of the cost of all lobster functions and builtins.

- use RangeCheck in more places.

- Should allow widening of types where no conversions are necessary:
  def f():
     for(..):
        return val
     nil
  Currently doesn't work, because we can't change how val is coerced.
  But simple widenings should be possible.
  Also currently no way to specify return types, so having to write val or nil is clumsy

- this crashes on += in codegen:
  team_colors := [ color_grey, color_red, color_blue, color_green, color_yellow, color_cyan, color_pink, color_light_red, color_light_green,
                   color_light_blue, color_light_yellow, color_light_cyan, color_light_pink, color_dark_red, color_dark_green, color_dark_blue, color_olive ]
  team_colors += map(48) i: team_colors[i % 16]

- second return value doesn't get proper vector type from e.g. gl_loadtexture:
  mapxy(xy { dim[0], dim[1] })

- weird error:
  struct controller { startpos:xyz_i = xyz_0i, endpos:xyz_i = xyz_0i, startinpal:int = false, endinpal:int = false, valid = false }
  controllers := map(2): controller {}
  error: no specialization of controller matches these types: xyz_i xyz_i int int int

- weird type error:
  if not (size == 0): // size is xyz_i
  error: "==" requires type: numeric/string/vector/struct, got: any

- also, == should not do pointer equality on value types! have to use equal for now

- excellent candidate for a 3D physics engine to integrate: https://github.com/RandyGaul/qu3e

- for any error related to a builtin function, can also print argument names and helptext.

- syntax: "if c: a, b = exp" doesn't compile if the multi-assign is on the same line.

- typechecker
  - x[i] does not do flow analysis.. not as trivial to add if i is an exp or could change.
  - if !a: a = ..
    // here a is still nillable.

  - flow analysis should also know about if !a: return; a // not nil here

  - if you do [int] + [float] you get "error: "+" (left argument) requires type: [any], got: [int]"

  - multimethods
    - multimethods are very restricted right now, having to declare an explicit return type or having to match
      return types.
      - always specialize the full multi-method, such that it needs less types to be specified?
    - the implementation is rather clumsy, and needing to dispatch on more than 1 arg so far has remained unused.
      - revert them to single dispatch?
    - need to disallow nilable types for args that are being dispatched on, since if the runtime value
      is ever nil, we can't choose a method. That, or have a way to have a method that works on nil alone.

  - You're able to pass a value to vector_reserve that's a different typeof than "return", which potentially
    gets the wrong type set.

  - with explicit conversion to any, there's now a lot of situations where an any gets generated, that is then
    subsequently ignored, causing unnecessary heap allocation.
    we should either:
    - mark functions (and if-thens, and other places where unions happen) explicitly as ignoring their return val,
      so we can generate pops for values as needed before they are returned.
    - or perculate desired types thru the type-check recursion.
      this can do more powerful typechecking, e.g. it can avoid the functions in "poweruptable" to have to specify
      a return type.
    - we could have a specific void (or nil) return type that causes values to be deleted and ignored.

  - should constants be excluded from freevars to reduce clutter?

  - must be able to derive type from default in struct def

  - can we avoid .length giving errors with variables initialized to [] before a push etc?

  - improve type checking doc.

  - move generic double check from parser to type checker init

  - why do we need .xy ? shouldn't xyz convert to xy when needed silently thru inheritance?

  - can we make the astar_node specialization less ugly?

  - struct pre-declaration can trip up IsGeneric.

  - should fields be allowed to have types of generic structs? can be a bit confusing that the containing
    struct becomes generic because of it but doesn't look generic.

  - the parser deciding between a field or function upon x.y is very brittle, the moment someone adds a field
    called "length" anywhere, suddenly all calls to length() don't work anymore.
    Only way to fix this is to delay this decision until typechecking.

  - add more cases to typecheck if-then optimisation.

  - Annotate builtin ops that truely want a vector, not a struct substitute.

  - returning an [int] from vector < ops is both incorrect and wasteful

  - what gets collected in "freevars" for each function is overly broad for HOFs, see CheckFreeVariable.
    This is benign, but would be nice to clean up.

  - explicit function types are currently a bit broken regarding return types, since if you don't care and
    specify any, a lot of functions will fail if they return ints etc.

  - see if we want to do something about the explosive cloning caused by gui.lobster
    we may want to use an explicit function type for situations like this, since we do want most HOFs to inline.

  - if you typecheck a function with a supertype, then a subtype is able to reuse it. But if the return value
    is now also this supertype you have a contravariance problem. Either must not reuse the function (but only
    if the return type is affected?) or subtitute the subtype somehow..
    This is affected by the order of source code, so can give weird errors.

  - flow sensitive checking does not work if part is skipped because a function has already been typechecked and
    is reused (same args and freevars), so should apply same demotes.
    Can this ever happen? can we guarantee it doesn't? Or for now just force a specialization if it has demotes?
    x := "" | nil
    function f(): x = nil
    if(x):  // promoted
        f() // demoted
    if(x):  // promoted
        f() // nothing happens, f() has already been typechecked

  - value structs are still compared by reference.. by value would be better, which also means we can choose
    to copy them and store them wherever.
    See e.g. gui.lobster/element()

  - check: a dynscope redef must have same type as its parent
  - improve GenScope now that we have pre-parsed sf.dynscoperedefs

  - make function calls with trailing nilable arguments default, as long as they're not ambiguous with sibling
    functions.

  - a := nil; a = 1 // allows creating nilable scalars, which we don't want, though its benign

  - We compile time optimize if-thens for constants, but this does not include cases that would
    need constant propagation, like astar_2dgrid isocta.
    Should reduce total cloning quite even further.
    issue: how can you do this with arguments that may be constant for the first call, but you
    don't know how many calls there will be yet?
    -> maybe we should analyze the if-then to be constant, but don't actually cull the code, leave
       that to a seperate optimisation pass. The branch will simply not be typechecked for this
       specialization.
       Though that would mean we'd need to make this boolean part of the type signature,
       because otherwise a second call with a different boolean value would reuse it,
       and run into un-type checked code.
       We already specialize on nilable/non-nillable, and specializing on booleans sounds attractive,
       though we don't generally want to specialize on ints or other values, unless we made a special
       annotation for it.
       We can stick an int value in the V_INT union for Type, and ignore it pretty much everywhere
       except for specialization.
       This does mean a lot more type allocations (one for every constant in the code, could hash).
       The type should propagate automatically.
       We'd have to be very careful about propagation, i.e. typechecking 1+a getting the type of 1.
       - any such combinations come almost always from Union(), so the amount of cases should be controllable.
         Also: variable binding.
         x.push(1) could make x a vector of 1's, and subsequent push of 2 doesn't fix that.'
       - also if someone writes 1+1, we'd have to eval that in the type checker.. we'd end up duplicating
         a bunch of functionality of the optimizer.. though that code is shared in ConstVal().
         In fact, if we expand that function, the optimizer can use it generically to optimize code,
         and doesn't have to repeat that code.
         Even better, the type checker can use it for generic typing, and reduce its code as well.
         Only downside is that its a bit more cpu intensive, since there is a double switch for each
         node, and worse, additional recursion which is only useful if it returns true.'
       Also must check there are no direct comparisons against type_int.
       We'd need a special value to mean not const (e.g. 0x80000000) which in this case is fine
       instead of an extra boolean.
       Then we check these values when we check for specializations.

  - we don't do flow-analysis for v[i] or v[i].f etc, is that possible?

  - need a better solution than replace() for assigning to read-only structs

  - from the previous astar_2dgrid:
        distancef := function(v): ...
        if(isocta):
            distancef = function(v): ...
        the assignment won't work. Now you could make it an if-then returning the function value,
        which will get you a dynamic call, and no specialization.
        frankly, its worth rewriting this such that it can be specialized, especially since thats
        free if isocta is contant

  - this language does very similar type inference, and has some interesting additional ideas:
    http://crystal-lang.org/2014/04/27/type-inference-rules.html
    - a "noreturn" type, that when you union it with some other type, you retain that other type rather than any.
      What scenario does this fix, though?
      an if-then-else with one of the two branches a return, and the value of the if-then-else as a whole still
      used? doesn't seem very common.
      It would mostly be useful with exception handling, in our case uses of "return from".
    - true union types rather than any.
      Not sure how useful this, since at runtime you still need the same type field, and knowing it can have
      a smaller set of possible types is not THAT useful, as it will still be slow.
      The biggest improvement would be in type errors, so now it can say instead of "expected int, got any"
      it will say "expected int, got int|string".
      Problem is that they are expensive to represent, as in its most generic form, they are a vector<Type>.
      We could cheat however, and make all the basic types (int/float/string) into INT_ANY etc variants, that
      have the other type as a subtype. Basically, the same as ANY for the purpose of most typechecking code,
      but carries more information for errors.
      It would also be useful for if(x is int):, because if x is ANY_INT, then the else branch x can have the
      parameter type (or if its ANY_FLOAT or ANY_STRING, and the parameter is INT).
      We can't do this with parametric types. Though in theory ANY_VECTOR could first have its own parameter followed
      by the second type, this won't work if either of those contain a struct/function/var type.
      Of course you could have VECTOR_ANY only work with int/float/string sub types, and the second type could be
      anything, which would be at least a small step forward, i.e. instead of "expected [int], got any", it
      can now say "expected [int] got [int]|[mytype]", but then if we have more complex types, it would have to
      resort to "[any]|[mytype]" (which is confusing) when really you want to say "[mytype1]|[mytype2]".
      In that case just "any" might be better?
      Of course, we could switch to a type representation where the index and the types fit in the same kind of
      fields, in which case we can represent any unions as long as there is space:
      STRUCT_ANY, idx1, STRUCT_ANY, idx2, STRUCT, idx3
      would be a union between 3 struct types.
      Simpler, we could bloat up the current union to allow 2 sub types, then any could simply be a union of
      those, and it would even work recursively.
    - It also does more accurate flow based tracking of variable types, e.g. an assignment inside
      an if() in Lobster only destroys the type promotion, here it changes the type promotion.
      That be easy to add, by storing the type promoted to rather than just the fact that something was promoted.

- In :: blocks, can now call other methods without "this", but:
  - also should be possible without () (see capped_storage() in cityclicker.lobster)
  - also should be possible to leave out variable name before ::

- There's a possibility gl_setmeshtexture will hold on to texture ids that get deleted.
  Would be nice to avoid this, but don't want Mesh to have to hold on to an LResource, or
  have to implement a second level of refcounting.

- remove last cases of RenderArraySlow
  - cache for text VBOs, and cache for arbitrary polygons, cleared if not used in a frame.

- create easy way to build Lobster as console-only language.

- This doesn't parse well (see std.lobster):
  for xs: acc1, acc2 = fun(acc1, acc2, _)

- improve indentation parsing, e.g. here it needs else to be at the same level as the var:
  v := if ..:
           ...
       else:
           ...

- should add readint/readfloat builtins, from any location in a string, with a given byte width, as little endian..
  allows things reading binary file formats, FlatBuffers, or custom memory efficient arrays etc.

- allow random number generator to be selected

- add a way to limit fps, regardless of what system is capable of.. particles in physics in particular doesn't function
  correctly at high fps.

- A path towards value types, less reference counting, and less runtime type information.
  - We can start with builtin functions, and mark arguments as not requiring reference counts
    increased, and thus all dec-refs can be removed from their code.
  - We add a set of pushvar and related instructions that does not inc-ref.
  - initially just in codegen, and extra arg to codegen for an exp says that the code should
    not inc-ref (using these new instructions, or if too complicated, just add a dec-ref).
    - actually adding a dec-ref is complicated, if an arg is a new string, or some exp that
      returns a new string, the dec-ref needs to be after the call if the builtin isn't going to
      dec-ref.
  - now in the type checker we can do an analysis wether any variable will ever have inc/dec-ref
    applied to it, this then transitively works through functions.
  - initially this just reduces reference counting overhead, but this paves the way for
    efficient value types.
  - We can now split reference types (initially just structs, later maybe vectors) in two types,
    where the value based one points to the memory after the reference count in a struct type.
    Value types are stored in-line, are passed by pointer, and assigned (and returned) by copy.
    Maybe the ref count can live before the pointer to keep the two compatible?
    To be precise, we got 3 types:
    - Value types, never ref-counted.
    - Struct non-ref-count, passed as if value type, only if can be analyzed to not need ref-counts.
    - Struct ref-counted, can be passed to non-ref-count context.
    Since there is already a value/struct distinction, we can start by making values stored
    in-line, before we even do analysis for structs.
    All of this is completely transparent for the user, as there will be no new errors generated,
    unlike say Rust. They will get the benefit from in-line types and low ref-count overhead
    pretty much for free.
  - Related to this is the removal of the type field currently in structs (and vectors), such
    that values can become completely naked and maximally efficient.
    In the type system, types are almost always already known statically, so we should be
    able to remove the type value, and have the compiler insert it as separate value (a hidden
    arg when needed for builtin calls that want an any type).
    This is of course best done once most uses of this type field have already been factored
    out.
    Or better yet, change the encoding of "any" such that it is a generic object that just
    bundles a type and a generic value, and is like a built-in value type. This can be used
    for "any" and dynamic dispatch.

- Improve 64bit builds.
  We currently can build for 32 and 64, and in the latter we use int64_t & double, which gives
  bonus precision, but uses exactly twice as much memory, since all Lobster memory is made out
  of these values.
  Suprisingly, for our unit-test path-finding benchmark, 64-bit mode this way is actually
  23% faster (VM mode, only 16% in C++ compilation mode), despite using more memory, that is
  apparently how much the VM code benefits from extra regs etc.
  Now this benchmark probably touches so little memory it all fits in cache, but for most
  Lobster programs that don't touch a ton of data, 64-bit mode is thus not a problem, in fact,
  it is a speedup.
  We can still improve this situation in two ways:
  1) Could allow types of different sizes at least in vectors and structs where they take the most space, and
     leave them uniform on the stack. Start with vectors as that's easiest and most impactful.
     Have a way to specify bit-width for both scalar types (only allowed to be smaller or equal to machine type).
     default would always be machine size everywhere.
     If we're lazy and don't want to deal with different sizes in structs, can at least allow size to specified
     for struct as a whole if all elements are scalar. This not only simplifies things by keeping
     indexing the as-is, but it allows faster vector ops by only having to check the bit-width
     once rather than every element.
     The advantage of the stack staying 64-bit is that you can then actually make use of 64-bit
     precision when you want to, something which is not the case in 2)
     How to implement:
     - Vectors can be created with an annotation to their desired bit-width, which becomes part of
       its type.
       - We have to ensure these get checked thru-out, so maybe safer to have special VECTOR_INT
         types etc.
     - Similarly, structs can be declared with a particular bit-width. They can be specialized into
       other bit-widths.
       - sub-typing check, cannot allow these specializations to be compatible with eachother.
     - In both cases, the bitwitdth is actually stored in the header of the object.
     - For direct loads and stores, we use specialized VM instructions, causing no overhead.
     - For generic code (builtins) that wants to read vector/struct elements, we provide a generic
       accessor function that dynamically loads the right size.
       - Sadly, there's no "read an int of n bytes" instruction in C++.
         Edit: there kinda is, see use of __movsb in flexbuffers.h
         on x86 you could read an int64 from the memory location, then use shifts to clear the unused bits
         that preserves the sign (>> is an ASR):
         value = ((value << 32) >> 32)
         to convert 32 to 64.
         though note: http://blog.regehr.org/archives/738
         On arm, unaligned access is allowed for single scalars on most v6 and all v7 architectures, so maybe its
         a non-problem.
         It will be slower, but since it only occurs for vectors that try to save memory, its probably ok.
         Can we avoid the unnecessary shifts when reading default size value (shifts will be 0) ?
         Still need a conditional for floats since the shift trick doesn't work there. Worse, now we generically need
         a conditional to check for floats.
         Maybe allow bit sizes only for ints?
         If its only for ints, how useful is it to have it at all? We already have a [byte], namely string, so it
         would only be for 16/32 bit int vectors.
       - frankly, a generic accessor function is a bad idea. Pretty much all builtins take a statically typed
         2/3/4 int/float structs, so we should be able to change the accessors to directly access these.
         Only problem is requiring them to be one size, e.g. 32bit. Even though we can maybe make the
         default specializations 32bit, people might expect to be able to specialize xyz for 64bit and
         still have all these functions work.
         We could overload all these functions..
       - Also would be helpful to change some vector builtins (like append) to lobster code, such that specialization
	     can still allow them to work on these vectors.
     - For compact structs, currently will be wasteful that in RefObj refc & ti can be 64-bits.
     1b) Alternatively, if the above is not all that crazy useful, implement my "typed buffers" approach
         and store the buffers inside strings.. doesn't need a new type, and allows all sorts of fun optimized
         data structures.
         Also cool for serialization.
         And helps more generally combat the heavy nature of non-inline objects.
         Then again, would be even better if structs could be separated from vectors more so we can add these
         features (variable data sizes, inline structs, trailing vectors) to regular structs.
		 Hmm, trailing vectors means reallocation, so not good to have in regular structs.
         Actually, no need to separate them, can just disallow them to be passed to generic vector functions.
         Only valid for structs that look like a vector.
  2) Could somehow make all the pointers stored in there into 32bit offsets in 64bit mode (and still raw
     pointers in 32bit).
     This would generally be good, since using less memory in 64bit could be quite a speedup.
     Problem is, there's no super elegant way of doing this.
     - Ideal would be if the OS would allow use to make all allocations come from a 32bit range, but there's
       no support for this.
       Instead, can use mmap() with MAP_NORESERVE on Linux/OSX/iOS/Android to just get a large chunk of memory,
       and then use that incrementally. Means we must have our own large block allocator however.
       On Windows VirtualAlloc can do the same.
     - could track all allocations in the allocator, but means also tracking "large" allocs individually,
       finding these in the table will slow things down, and means code can't run with the base allocator anymore.
     - simpler, could require the allocator to re-alloc when it needs to grow. If we can guarantee all pointers
       in it and towards it are offsets, this can work.
       Problem is that these large reallocs can fail, i.e. might not work well for memory contrained systems such
       as iOS whenever it goes full 64bit.
       Also means we can't use the base allocator anymore.
     - Could track all allocations in an IntResourceManagerCompact.. that's a fair bit of extra memory usage
       though for small objects.
     The problem with this approach is that there is no way to do operate on 64bit datatypes in any way this way.
     Another problem: the ip's stored in Value are native function pointers in C++ mode and would need to
     be indirected.

- add support for http://vallentinsource.com/opengl/debug-output

- Add #line to C++ output: http://yosefk.com/blog/c-as-an-intermediate-language.html

- Implement these examples in gui.lobster: https://github.com/eugenkiss/7guis/wiki

- in VM stack traces, linenumbers for blocks if/then etc often refer to 1 beyond the last line of their body,
  which is unhelpful. Should see which instruction they refer to, and which node generates that lineinfo.

- should redo gui.lobster to take all args in virtual float coords, not some in float font relative coords and some
  in pixels.

- should consider allowing local functions to be declared with "public", which would expose them to closures called
  from within their parent function. This would allow the whole definition of gui.lobster to be inside gui_start.
  It would create kind of an inverted object, so all calls could lose the gui_ prefix since they're not global anymore.
  Would probably work together well with frame state.

- the "ERROR: XAudio2: XAudio2Create() failed at initialization" is apparently happening on all sorts of cheap laptops,
  including Win7 & 8. SDL folk don't seem to want to fix, it, maybe I should

- supposedly on OS X error window OK button is not clickable?

- add more to http://rosettacode.org/wiki/Category:Lobster
  once there's no more syntax changes.
  https://www.google.com/search?as_q=&as_epq=You+are+encouraged+to+solve+this+task+according+to+the+task+description%2C+using+any+language+you+may+know.&as_oq=&as_eq=&as_nlo=&as_nhi=&lr=&cr=&as_qdr=all&as_sitesearch=http%3A%2F%2Frosettacode.org%2F&as_occt=any&safe=images&as_filetype=&as_rights=#as_qdr=all&q=site:http:%2F%2Frosettacode.org%2F+%22You+are+encouraged+to+solve+this+task+according+to+the+task+description%2C+using+any+language+you+may+know.%22

- docs:
  - not clear
    - value ... people used to doing v.x +=
    - else: if:
    - that you can make your own control structs in your own code: examples focus a bit too much on for/if
    - the single graphics matrix stack
    - more on debugging
  - tutorials
    - absolute basics for those that don't know programming yet
  - shader system
  - performance - do benchmarking
  - gui system
  - better language cheat sheet ?
  - web page:
    - link to reference and docs more for things that are not explained (e.g. ::)
    - more images to cool samples written in lobster, to entice what the language can do.
    first maybe add more/better examples

- examples:
  - more/better examples..
  - also make more basic games people can start from

- builtin functionality
  - stb
    - try out stb truetype
    - ogg loading -> stb (streaming vs loading?)
  - more sound functions: stopping a sound early, volume, getting notification when a sound stops playing,
    software-based audio mixing, some way to loop sounds.
  - sphere-to-frustum intersection for easy culling
  - TCP-IP? enet?
  - threading
  - JSON
  - launching processes and other shell stuff

- disadvantage to Lobster being based on immediate mode rendering is that that is quite taxing on the speed of the
  language, since you need so much code to just decide what to render each frame
  directions:
  - add display lists or something so it is easy to cache rendering calls, and the code generating them doesn't need
    to be called every frame
    ideal for level backgrounds etc.
    though complicates things a tiny bit, as now you have to decide manually when to re-render certain display lists
  - have an additional retained mode system (probably combined with physics) that would be doubly useful
    in some cases
  - work on optimizing the language a bit more

- when running with no args (trying to load a .lbc), current dir should be aux dir when running from commandline

- make it more straight forward to use as an embeddable scripting language
  - add functionality to call individual functions inside a script

- think about how to support a debugger
  - would be great if it could be written in Lobster itself:
    have to figure out how to have a frozen VM, and have debugger code running
    and how they can share graphics state
    maybe we can allow multiple windows to start? can make objects that hold window+context+all other graphics state,
    and allow each VM to open 1, or even multiple per vm
    if that approach doesn't work, can make a debugger that is a webserver inside the lobster exe, as that's nice and
    cross platform.
    But better to try multiple windows first, that be good for threading and other features anyway.
  - Actually a web-server based debugging interface might be good, use e.g. this:
    http://runtimelegend.com/tech/webserver/
  - might be fun to see how hard it is to write an integration for http://lighttable.com/
    which could be used as a debugger and maybe for live-coding.
  - Could integrate with VSCode instead.

- function f(): x := 1; x + x
  gives error on x... should disallow

- make win32 version not a console app
  - need to save lobster text output always to a file, so when it crashes user can send me that
  - can always type/cat it to show output
  - ideally lobster has a callback for program output & errors
  - trace output also to a file

- BitmapFont::height is often 1 or 2 bigger than the original fontheight, which creates problems if code use the
  fontheight for rendering instead of gl_textsize()
  either improve the math such that they are guaranteed equal, or document that fontheight should never be used for
  rendering bounding boxes etc

- Icon style matching on vectors or strings, whereby the current vector and position are stored globally, so you can
  easily write match('a') | match('b') etc. and find() and other type of searches/matches that string function and
  regexps generally do. And easy string extraction functions.
  Could use a HOF to be the stack context of these functions ... can even write it in Lobster itself (with private DS
  variables) if speed isn't an issue.
  can support coroutines as a source too.

- coroutines:
  - having convenient syntax for resuming coroutines at a variety of entry points to simulate methods would be very cool
  - speedup local access
  - state tags: allowing blocks to be tagged such that its easy to query externally which "state" a coroutine is in

- transforms:
    - cannot use matrix functionality for own matmuls etc -> need loadmatrix etc
    - localmousepos and hit are nonsensical when perspective is on

- should all gl calls check minimized themselves for programmers that don't check gl_visible() (gl rendering when
  minimized crashes on IOS)

- multiple return values:
  - builtin functions that return 0 values:
    - first have to solve that when used as last call in a function, then that function still requires a return value
    - thus can't make it an error
    - could ideally have 0 returns not cause a pop

- for mgtest or other games with long load time, have a way to not have an uninitialized window while loading
  - could add a system for threading long operations like this...
  - or an easy way to render a first frame?

- a program that reformats lobster code to conform to the style-guide better.
  Not a trivial program since it can't reuse the existing Lobster lex/parser, since that throws too much information
  away
  Will need to be a "conservative" program, yet it must understand enough of program structure (with indents and
  multi-line exps) to reformat correctly.
  Must also respect aligned spacing in places.

- calling mg_scalevec(1, f) where f = nil doesn't work (see codegen NCM_CONT_EXIT).. probably doesn't happen a lot, but
  needs fixing

- other IQM features
  - make bone count dependent on max uniforms, and make it an error to load a model over that.. or find out what minimum
    uniform count is on relevant OpenGL ES 2 devices
  - can very easily count max weights and choose a shader with less mats
    maybe add some conditional feature to the shader parser to make this easier
  - currently scaling is multiplied into the mats if its in the file. Either make scaling an error, or use this to
    transfrom the normal:
    mat3 madjtrans = mat3(cross(m[1].xyz, m[2].xyz), cross(m[2].xyz, m[0].xyz), cross(m[0].xyz, m[1].xyz));
    http://www.arcsynthesis.org/gltut/Illumination/Tut09%20Normal%20Transformation.html
  - maybe use dual quats?

- improve gui.lobster
  - pop up menus
  - multiline text editing system

- should lobster transition to a callback model per frame? that's how mobile devices like to interact with your program,
  and SDL does some pretty nasty stuff to emulate the pc way of doing things on there.. can we bypass that?
  Hmm that doesn't require a new programming model.. we can just have gl_frame() suspend the VM so we can return from
  our frame callback

- optimisations:
  - could add an optimizer with constant folding, constant propagation and inlining, esp inlining of hofs very important
    - ideally, need to additionally have a way to do while/if/for without function values, while is terrible atm
  - think of ways to simplify function calling
    could keep a simple function reference count, so we can only do the expensive backupping for recursive functions
    NOTE: recursive calls are not the only situation that requires backups. A simple map(): map(): .. does not look
    recursive, but has the same implications.

- per function real cpu profiling would not be too expensive
  just a single qpc per call -> no, 2, needs stack
    no, can do it stackless if we change the "definedfunction" saving to keeping a current one and saving the previous,
    that way on each function entry/exit we know who to attribute the current elapsed time to
  gotta be able to display hierarchically blocks under named functions
  alternatively, could just do a ++ every instruction to count instructions... not quite as accurate an indication of
  performance, and harder to display compactly since you'd have to display it next to the lines in source

- compressed loading/saving using my entropy encoder

- threading might be fun to try out for something like smallpt
  - can then either launch threads using the same mechanism as compile_run (pass strings between threads)
    or maybe better just instantiate more VMs based on the same bytecode, that way we can
    - pass data structures with refc==1 (if we share an alloc, though then all allocs must be threadsafe)
    - or clone em (still a lot better than parsing), though to clone, need to access other VMs allocator?
    hmm it be really nice to keep slaballoc thread-unsafe, so maybe it has to go thru an intermediary copy
  what about SDL being optional, and we'd like to use its threading functionality? (see elsewhere)

- could we remove the support for dynamic scoping alltogether?
  - DS thru -> would be more accurate if it was followed by a block itself
  - DS in general is almost superseded by lobsters HOFs because they do take a block. i.e. gl_color() is nicer than
    doing gl_color <-

- didn't solve no mouse up msg when leaving window

- see if we can get page aligned memory with VirtualAlloc / mmap for slaballoc

- making SDL manditory:
  + it's already mandatory on Android/iOS
  + can use SDL log/file/thread abstractions.. threading in particular!
  + error handling
  + can make features that rely on graphics, like a graphical console/print, graphical debugging, could kill the DOS
    console
  + if graphics are mandatory, frame based state makes more sense.. its a bit odd if such a thing is a gl_ feature, but
    hey why not
  - no more console-only programs possible.. reduces its usefulness as a general purpose programming language
  - don't want to have it initializing graphics before compilation... probably can just do it before VM init
  - killing DOS console means giving up notepad++ integration
  - right now, lobster could be used as a plug-in scripting language by simply not binding all the graphics stuff
  at first we can just init SDL at the start of the program, then graphics optionally during execution. this gives us a
  lot of the combined benefits.. the only thing we lose is not being able to be a plug-in language
  alternatively, we can make on-demand init of SDL a bit more modular, so that it can be called upon when threading is
  needed etc.

  Ideally the dependency graph is:
  base <- engine    <- bindings <- main
       ^- compiler  <-/
  So someone can use just the compiler without the engine.
  A simplified version would just be (this is the current situation):
  compiler <- engine <- main
  In VS, the language project compiles without needing SDL or anything beyond stdlib, we
  should keep it that way
  The usefulness of being able to use the engine without the compiler is low.
  Engines are a dime a dozen, and this one is not particularly featureful, and quite specific to
  its bindings. If you really ever wanted to do a C++ project with this engine and without
  using Lobster, the fact that the compiler is compiled in doesn't hurt anyone.

- some kind of profiler:
  - measure instruction inside named function
  - number of calls of builtin functions

- a := a // where a is an arg is allowed

- dispatcher:
  - rewrite the dispatcher to be in tree form
  - can add subtypes that don't have their own case? how about single variant functions?
  - make type+idx into shorts, so they can be checked with a single compare?

- "is" doesn't deal with subtypes

- bytecode version of compile_run()

- typing:
  - also support withtype for "method calls"
  - ::= op (first find a convincing use for it)
  - could make it a warning or error if X.field is used where X has been withtyped

- get rid of client side data VB rendering by putting rect/line/circle etc in a static vbo, then transform with mvp or
  uniform

- fix localmousepos to be a position in front of the camera in 3d mode? and in the middle in no cursor mode?

- hiding the console unless there's output for graphical applications
  note this screws up notepad++ capturing output

- force coroutines to be top level functions to protect people against running into an undefined on resume if they use
  a free var?

- multiple errors

- make comparators non-associative?

- some form or switch or pattern match facility?
- pattern matching by failing a function into the next

- make bytecode, not intcode.

- FIXMEs

TYPECHECKER NOTES:
==================
- free variable pre-specialization implementation:
  in essence, to be fully correct, a function value must be specialized to its free variables when the
  the function value is *created*, and to its args when it is *called*.
  We must thus specialize at creation time.
  This first requires we use SubFunctions as type-ids because otherwise this specialization will
  get lost thru multiple calls. This should not affect us using Function ids for return-from etc, as these
  can still be retrieved.
  Then, how to specialize:
  at creation time:
  if first sf is not freevarchecked, just use that one and mark it as such.
  otherwise, check all specializations (typechecked or not, but only with flag freevarchecked) for a match in freevars.
  otherwise, if none of the current specializations fit the current free vars, force a clone, and point to that.
  Make sure we set the types of the freevars to their current values (move from TypeCheckCall).
  this forces that type-system-wise, no two functions with different free vars have the same id.
  Might make sense that if there are already multiple subfunctions that have matching freevars we always pick the
  last one (the first one added), such that these kinds of function values always have the same type, though it
  may not matter.
  This should not affect function type definitions, as this is an explicit type check
  at call time:
  We must now not terminate at the first untypechecked function.
  If the current sf is not type-checked, we can simply go ahead and use it.
  Otherwise, checking all alternatives includes freevars, so will select or clone the right one.


CURRENT SOLUTION FROM TRADEOFS:
===============================
- try to measure the cost of removing exception handling from lobster: turning exceptions of will
  have a gain that my compensate for the branch not taken needed for explicit error handling.
  - Both VS and gcc appears to be 1% faster with exceptions off.
  - adding an extra termination conditional in EvalProgram is 7% slower in VS, and 0.5% faster
    with gcc (manages to infer no exception can be thrown?)
    Combining the conditional with no-exceptions doesn't seem to make much of a difference for
    either compiler.
  - Would need to revert to a switch to make this exit cheaper, but switch is also about 7%
    slower in VS than trampoline, with or without exceptions.
  Conclusion: stick with exceptions (and trampoline) for now.

- you can hit multiple overlapping hit boxes with gl_hit(). problem is, you render back to front, but want to hit test front to back...
    - if you simply clear that a hit happened this frame when its tested, you get that order wrong
    - if you added z-layers to rendering such that you could do inverse order
      - if you did it immediate mode, blending wouldn't work correctly, so it would have to be understood that if you did did multiple layers for hit testing, you can't hit on an alpha element
      - could store all render calls and sort (or just reverse) them after, but this is a lot of storing of stuff
        we would store color/blend/transform/shader/texture/linemode for each, which is not that much of an overhead since we set these things on every render op anyway
        (except blend/texture/linemode which can be set when changed),
        so its purely the cost of allocating/storing, and complicating the code a little
    - could track an event handling closure and handle it it at the end of the frame. certainly the simplest, if not totally elegant
      (extra call to handle delayed closure, and delayed closure can't access free variables)
    - you could compare the current hit rect against the last rect that was hit last frame, and if they are the same, this is the one to fire
      problem is, this doesn't work on touch screens, where you lose the first touch down event this way
      -> unless you delayed all touch down events by one frame, to give one hover frame to register (this is the current solution)
    regardless of the solution above, you also need an additional way to cancel hits that happen inside a toolbar or statusbar that may not have hittests everywhere
    -> that can already be done by a gl_hit that doesn't react to it's return value

- for things like GUI callbacks, lobsters non-escaping free var function values kinda suck. options:
  - just call em in place, can only really work in a non-immediate mode gui since otherwise the callback can change the gui layout
    - use caller_id() to make the gui aware of inserts/deletes so this is now safe <- curent solution
      - instead of caller_id could have created a vector of args to the gui function as identity. slightly more correct for calls in a loop, but more work.
    - alternatively since all troubles are caused by element insertion/deletion, have special functionality for turning things on/off, i.e. gui_if() instead of if()
  - call em afterwards: problematic because variables not available
  - call em afterwards & force it to take an arg. not elegant, but atleast the arg will remind people to pass values this way
  - wrap in coroutine so the variable is captured... hard to do since you want to continue with other code after the yield
  - implement full closures for escaping situations
    - don't really want another programming language feature just for this
    - to create closure, would need syntax at the call site which is clumsy if it gets forgotten, and some new data structure to hold vars
    - would have to back up old vars, load vars from closure, call function, and put old vars back
    - would probably have a special way to invoke closures so that we don't have to clutter normal function calling, and its easy to give errors if a non-closure is passed in
      still, there has to be some indication on the stack that we're returning from a closure
      though I suppose it can work like coroutines, where upon returning from the function it hits a special instruction that does the cleanup
    - maybe also have a static type for it so no syntax is needed at the call site
    - could we piggyback on coroutine resume? almost, but not quite.. it wouldn't restore the free vars upon ending the function, for example
      hmm that could maybe be fixed with a special cleanup instruction
    - so in summary the implementation effort is a simplified version of what coroutines currently do

NOTES:
======
- mrgreenfur has the lobster.io domain we could use as a new homepage..
- http://rigaux.org/language-study/syntax-across-languages.html

SPEED TESTS
===========
secs measured in release win32 on speedtest.lobster, all other figures in debug.

2600K
VM: last_dyn_typed: secs 10.11, ins 599572240, fcall 57534476, bcall 2534535, totalalloc 4501531,  59.3m ins/sec.
VM: last_switch   : secs  7.65, ins 528287030, fcall 53352301, bcall 3283290, totalalloc 4528586,  69.1m ins/sec.
VM: over fun ptr  : secs  6.99, ins 528287030, fcall 53352301, bcall 3283290, totalalloc 4528586,  75.6m ins/sec.
C++: first comp   : secs  4.85, ins 528287030, fcall 53352301, bcall 3283290, totalalloc 4528586, 108.9m ins/sec.
VM: first inline  : secs  6.55, ins 511702691, fcall 34036002, bcall 3289786, totalalloc 4559054,  78.1m ins/sec.
C++: first inline : secs  4.31, ins 511702691, fcall 34036002, bcall 3289786, totalalloc 4559054, 118.7m ins/sec.
VM: inlined for   : secs  5:19, ins 532311325, fcall 10848019, bcall 3285282, totalalloc 4528342, 102.7m ins/sec.
C++: inlined for  : secs  2.86, ins 532311325, fcall 10848019, bcall 3285282, totalalloc 4528342, 186.1m ins/sec.

8700K
VM: inlined for   : secs  2.92, 1.77x vs 2600K
C++: inlined for  : secs  2.00, 1.43x vs 2600K
VM64: inlined for : secs  2.38, 1.23x vs 32bit
C++64: inlined for: secs  1.72, 1.16x vs 32bit
VM: vec/struct    : secs  2.64
VM64: vec/struct  : secs  2.11
VM64: may 2018    : secs  2.15
VM64: compr_ptr   : secs  2.02, 1.07x vs native pointers


DEPENDENCIES
============


node.h
    [typechecker.h]
    [codegen.h]

lex.h
    ttypes.h

idents.h
    [node.h]
    natreg.h

disasm.h
    natreg.h
        vmdata.h
            il.h
    bytecode_generated.h
